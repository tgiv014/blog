<!doctype html><html lang=en dir=auto>
<head><meta charset=utf-8>
<meta http-equiv=x-ua-compatible content="IE=edge">
<meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no">
<meta name=robots content="index, follow">
<title>Project Euler Problem #15 | mntn.dev</title>
<meta name=keywords content="algorithms">
<meta name=description content="Three ways to tackle Project Euler Problem #15">
<meta name=author content="Thomas Gorham">
<link rel=canonical href=https://mntn.dev/posts/1-project-euler-15/>
<link crossorigin=anonymous href=/assets/css/stylesheet.min.c88963fe2d79462000fd0fb1b3737783c32855d340583e4523343f8735c787f0.css integrity="sha256-yIlj/i15RiAA/Q+xs3N3g8MoVdNAWD5FIzQ/hzXHh/A=" rel="preload stylesheet" as=style>
<script defer crossorigin=anonymous src=/assets/js/highlight.min.7680afc38aa6b15ddf158a4f3780b7b1f7dde7e91d26f073e6229bb7a0793c92.js integrity="sha256-doCvw4qmsV3fFYpPN4C3sffd5+kdJvBz5iKbt6B5PJI=" onload=hljs.initHighlightingOnLoad()></script>
<link rel=icon href=https://mntn.dev/favicon.ico>
<link rel=icon type=image/png sizes=16x16 href=https://mntn.dev/favicon-16x16.png>
<link rel=icon type=image/png sizes=32x32 href=https://mntn.dev/favicon-32x32.png>
<link rel=apple-touch-icon href=https://mntn.dev/apple-touch-icon.png>
<link rel=mask-icon href=https://mntn.dev/safari-pinned-tab.svg>
<meta name=theme-color content="#2e2e33">
<meta name=msapplication-TileColor content="#2e2e33">
<meta name=generator content="Hugo 0.89.4">
<noscript>
<style>#theme-toggle,.top-link{display:none}</style>
<style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--hljs-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style>
</noscript><meta property="og:title" content="Project Euler Problem #15">
<meta property="og:description" content="Three ways to tackle Project Euler Problem #15">
<meta property="og:type" content="article">
<meta property="og:url" content="https://mntn.dev/posts/1-project-euler-15/"><meta property="article:section" content="posts">
<meta property="article:published_time" content="2020-11-13T17:00:00-05:00">
<meta property="article:modified_time" content="2020-11-13T17:00:00-05:00"><meta property="og:site_name" content="mntn.dev">
<meta name=twitter:card content="summary">
<meta name=twitter:title content="Project Euler Problem #15">
<meta name=twitter:description content="Three ways to tackle Project Euler Problem #15">
<script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://mntn.dev/posts/"},{"@type":"ListItem","position":2,"name":"Project Euler Problem #15","item":"https://mntn.dev/posts/1-project-euler-15/"}]}</script>
<script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"Project Euler Problem #15","name":"Project Euler Problem #15","description":"Three ways to tackle Project Euler Problem #15","keywords":["algorithms"],"articleBody":"Intro Problem #15 from Project Euler is a really interesting problem. Not only is there a clean mathematical solution to the question, but there are a bunch of non-optimal (or even downright ugly) but intuitive ways to solve the problem.\nThe Easy Way The easiest, and probably fastest, way to solve this problem is to just use math. Consider the rules of the problem:\n Each path is composed of 2N steps that lead from the top left to the bottom right of the domain. Each step can only be a rightward or downward move. Because of the start and end positions, each path must have an equal number of down and right moves.  Based on these rules, you can build a valid path by starting with an empty list of 2N steps, selecting N steps to place a rightward move, and filling the remaining steps with downward moves. This is a Combination Problem! The number of valid paths you can possibly construct is 2N choose N.\nA Fun Way   Maybe you‚Äôre itching for a reason to think about binary trees. You can look at every step in a path as a node in a binary tree. The starting position is the root node. The root node has two child nodes, one for a downward move and one for a rightward move. Each of those nodes have their own children in the same pattern. This means that two of the ‚Äúgrandchild‚Äù nodes actually describe different paths to the same point. In the above picture, downward moves are to the left and rightward to the right.\nUsing this tree, we can describe any path on an infinite grid. To constrain the grid (and know when we‚Äôve reached the end point), we need to add some state to each node: an x and y position: (x,y). To create a new downward node in our domain, y must be less than N - the new node‚Äôs y value will be increased by 1. To create a new rightward node, x must be less than N - we‚Äôll increase the node‚Äôs x. If a new node has state x == N and y == N, we‚Äôve hit the end point of the grid!\nIf we actually build out this tree to full 2N depth, we‚Äôll eat up a ton of memory. Conveniently, we don‚Äôt actually need to hold all of this state since we‚Äôre only interested in how many nodes in the tree are at the end point. We can just pretend to build the tree with a recursive function. Here‚Äôs an implementation in Rustü¶Ä:\n// The size of our domain in steps // The grid is NxN steps // Really, our position grid is N+1xN+1 // [0,0] describes the start and [N,N] describes the end point static N:u32 = 20; fn build_node(x:u32, y:u32, n_ends:\u0026mut u64) { // If x==y==N, we're at the end point!  if x == N \u0026\u0026 y == N { *n_ends += 1; return; } // Recurse for each child node if possible  if x  N { build_node(x + 1, y, n_ends); } if y  N { build_node(x, y + 1, n_ends); } } fn main() { let mut n_ends:u64 = 0; // This describes the root node  build_node(0, 0, \u0026mut n_ends); println!(\"Total unique paths: {}\", n_ends); } Go get a coffee or two, because this took ~30min to run on my machine.\nEdit: This can be heavily optimized without abandoning the tree structure! More info in this more recent post.\nAn ugly way Suppose you were told to solve this problem on an FPGA and you have no clue what combination is. Since we know the length of a path is 2N, we‚Äôll start with a 2N-bit wide counter. Let‚Äôs say down = 1 and right = 0. We can initialize a down-counter with all 1s and let it run all the way down to 0. Since we know a valid path has #rights=#downs=N, we‚Äôll look at every counter value and keep track of the number of values which have exactly N ones. That number is the number of possible paths!\nWe can even slightly optimize this by recognizing that we only have to evalute all of the paths that start with a downward move and multiply the result by two. This follows from our tree representation above. Rust example below:\n// The size of our domain in steps static N:u32 = 20; fn main() { let n_ends:u64 = (2u64.pow(2*N-1)..2u64.pow(2*N)).map(|x| (x.count_ones()==N) as u64).sum(); println!(\"Total unique paths: {}\", 2*n_ends); } Go get another coffee. This took ~15 minutes on my machine. In the end, the mathematical solution is the way to go, but it‚Äôs still fun to explore other solutions.\n","wordCount":"781","inLanguage":"en","datePublished":"2020-11-13T17:00:00-05:00","dateModified":"2020-11-13T17:00:00-05:00","author":{"@type":"Person","name":"Thomas Gorham"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://mntn.dev/posts/1-project-euler-15/"},"publisher":{"@type":"Organization","name":"mntn.dev","logo":{"@type":"ImageObject","url":"https://mntn.dev/favicon.ico"}}}</script>
</head>
<body id=top>
<script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add('dark'):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove('dark'):window.matchMedia('(prefers-color-scheme: dark)').matches&&document.body.classList.add('dark')</script>
<header class=header>
<nav class=nav>
<div class=logo>
<a href=https://mntn.dev/ accesskey=h title="mntn.dev (Alt + H)">mntn.dev</a>
<span class=logo-switches>
<button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg>
</button>
</span>
</div>
<ul id=menu>
<li>
<a href=https://mntn.dev/search/ title="search (Alt + /)" accesskey=/>
<span>search</span>
</a>
</li>
<li>
<a href=https://mntn.dev/projects/ title=projects>
<span>projects</span>
</a>
</li>
<li>
<a href=https://mntn.dev/categories/ title=categories>
<span>categories</span>
</a>
</li>
<li>
<a href=https://mntn.dev/tags/ title=tags>
<span>tags</span>
</a>
</li>
</ul>
</nav>
</header>
<main class=main>
<article class=post-single>
<header class=post-header>
<div class=breadcrumbs><a href=https://mntn.dev/>Home</a>&nbsp;¬ª&nbsp;<a href=https://mntn.dev/posts/>Posts</a></div>
<h1 class=post-title>
Project Euler Problem #15
</h1>
<div class=post-meta><span title="2020-11-13 17:00:00 -0500 -0500">November 13, 2020</span>&nbsp;¬∑&nbsp;4 min&nbsp;¬∑&nbsp;Thomas Gorham&nbsp;|&nbsp;<a href=https://github.com/tgiv014/blog/posts/1-project-euler-15/index.md rel="noopener noreferrer" target=_blank>Suggest Changes</a>
</div>
</header>
<div class=post-content><h1 id=intro>Intro<a hidden class=anchor aria-hidden=true href=#intro>#</a></h1>
<p><a href="https://projecteuler.net/problem=15">Problem #15</a> from <a href=https://projecteuler.net/about>Project Euler</a> is a really interesting problem. Not only is there a clean mathematical solution to the question, but there are a <em>bunch</em> of non-optimal (or even downright ugly) but intuitive ways to solve the problem.</p>
<h1 id=the-easy-way>The Easy Way<a hidden class=anchor aria-hidden=true href=#the-easy-way>#</a></h1>
<p>The easiest, and probably fastest, way to solve this problem is to just use math. Consider the rules of the problem:</p>
<ol>
<li>Each path is composed of <em>2N</em> steps that lead from the top left to the bottom right of the domain.</li>
<li>Each step can only be a rightward or downward move.</li>
<li>Because of the start and end positions, each path must have an equal number of down and right moves.</li>
</ol>
<p>Based on these rules, you can build a valid path by starting with an empty list of <em>2N</em> steps, selecting <em>N</em> steps to place a rightward move, and filling the remaining steps with downward moves. This is a <a href=https://en.wikipedia.org/wiki/Combination>Combination Problem</a>! The number of valid paths you can possibly construct is <em>2N choose N</em>.</p>
<h1 id=a-fun-way>A Fun Way<a hidden class=anchor aria-hidden=true href=#a-fun-way>#</a></h1>
<figure>
<img loading=lazy src=treediagram.png>
</figure>
<p>Maybe you&rsquo;re itching for a reason to think about binary trees. You can look at every step in a path as a node in a binary tree. The starting position is the root node. The root node has two child nodes, one for a downward move and one for a rightward move. Each of those nodes have their own children in the same pattern. This means that two of the &ldquo;grandchild&rdquo; nodes actually describe different paths to the same point. In the above picture, downward moves are to the left and rightward to the right.</p>
<p>Using this tree, we can describe any path on an infinite grid. To constrain the grid (and know when we&rsquo;ve reached the end point), we need to add some state to each node: an x and y position: (x,y). To create a new downward node in our domain, y must be less than <em>N</em> - the new node&rsquo;s y value will be increased by 1. To create a new rightward node, x must be less than <em>N</em> - we&rsquo;ll increase the node&rsquo;s x. If a new node has state <em>x == N</em> and <em>y == N</em>, we&rsquo;ve hit the end point of the grid!</p>
<p>If we actually build out this tree to full <em>2N</em> depth, we&rsquo;ll eat up a ton of memory. Conveniently, we don&rsquo;t actually need to hold all of this state since we&rsquo;re only interested in how many nodes in the tree are at the end point. We can just pretend to build the tree with a recursive function. Here&rsquo;s an implementation in Rustü¶Ä:</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=color:#75715e>// The size of our domain in steps
</span><span style=color:#75715e>// The grid is NxN steps
</span><span style=color:#75715e>// Really, our position grid is N+1xN+1
</span><span style=color:#75715e>// [0,0] describes the start and [N,N] describes the end point
</span><span style=color:#75715e></span><span style=color:#66d9ef>static</span> N:<span style=color:#66d9ef>u32</span> <span style=color:#f92672>=</span> <span style=color:#ae81ff>20</span>;

<span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>build_node</span>(x:<span style=color:#66d9ef>u32</span>, y:<span style=color:#66d9ef>u32</span>, n_ends:<span style=color:#66d9ef>&amp;</span><span style=color:#a6e22e>mut</span> <span style=color:#66d9ef>u64</span>) {
    <span style=color:#75715e>// If x==y==N, we&#39;re at the end point!
</span><span style=color:#75715e></span>    <span style=color:#66d9ef>if</span> x <span style=color:#f92672>==</span> N <span style=color:#f92672>&amp;&amp;</span> y <span style=color:#f92672>==</span> N {
        <span style=color:#f92672>*</span>n_ends <span style=color:#f92672>+=</span> <span style=color:#ae81ff>1</span>;
        <span style=color:#66d9ef>return</span>;
    }
    <span style=color:#75715e>// Recurse for each child node if possible
</span><span style=color:#75715e></span>    <span style=color:#66d9ef>if</span> x <span style=color:#f92672>&lt;</span> N {
        build_node(x <span style=color:#f92672>+</span> <span style=color:#ae81ff>1</span>, y, n_ends);
    }
    <span style=color:#66d9ef>if</span> y <span style=color:#f92672>&lt;</span> N {
        build_node(x, y <span style=color:#f92672>+</span> <span style=color:#ae81ff>1</span>, n_ends);
    }
}

<span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>main</span>() {
    <span style=color:#66d9ef>let</span> <span style=color:#66d9ef>mut</span> n_ends:<span style=color:#66d9ef>u64</span> <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>;
    <span style=color:#75715e>// This describes the root node
</span><span style=color:#75715e></span>    build_node(<span style=color:#ae81ff>0</span>, <span style=color:#ae81ff>0</span>, <span style=color:#f92672>&amp;</span><span style=color:#66d9ef>mut</span> n_ends);
    println!(<span style=color:#e6db74>&#34;Total unique paths: {}&#34;</span>, n_ends);
}
</code></pre></div><p>Go get a coffee or two, because this took ~30min to run on my machine.</p>
<p><em>Edit: This can be heavily optimized without abandoning the tree structure! More info in <a href=/blog/project-euler-15-addendum>this more recent post</a>.</em></p>
<h1 id=an-ugly-way>An ugly way<a hidden class=anchor aria-hidden=true href=#an-ugly-way>#</a></h1>
<p>Suppose you were told to solve this problem on an FPGA and you have <em>no clue</em> what combination is. Since we know the length of a path is <em>2N</em>, we&rsquo;ll start with a <em>2N</em>-bit wide counter. Let&rsquo;s say down = 1 and right = 0. We can initialize a down-counter with all 1s and let it run all the way down to 0. Since we know a valid path has #rights=#downs=<em>N</em>, we&rsquo;ll look at every counter value and keep track of the number of values which have exactly <em>N</em> ones. That number is the number of possible paths!</p>
<p>We can even slightly optimize this by recognizing that we only have to evalute all of the paths that start with a downward move and multiply the result by two. This follows from our tree representation above. Rust example below:</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=color:#75715e>// The size of our domain in steps
</span><span style=color:#75715e></span><span style=color:#66d9ef>static</span> N:<span style=color:#66d9ef>u32</span> <span style=color:#f92672>=</span> <span style=color:#ae81ff>20</span>;

<span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>main</span>() {
    <span style=color:#66d9ef>let</span> n_ends:<span style=color:#66d9ef>u64</span> <span style=color:#f92672>=</span> (<span style=color:#ae81ff>2</span><span style=color:#66d9ef>u64</span>.pow(<span style=color:#ae81ff>2</span><span style=color:#f92672>*</span>N<span style=color:#f92672>-</span><span style=color:#ae81ff>1</span>)<span style=color:#f92672>..</span><span style=color:#ae81ff>2</span><span style=color:#66d9ef>u64</span>.pow(<span style=color:#ae81ff>2</span><span style=color:#f92672>*</span>N)).map(<span style=color:#f92672>|</span>x<span style=color:#f92672>|</span> (x.count_ones()<span style=color:#f92672>==</span>N) <span style=color:#66d9ef>as</span> <span style=color:#66d9ef>u64</span>).sum();
    println!(<span style=color:#e6db74>&#34;Total unique paths: {}&#34;</span>, <span style=color:#ae81ff>2</span><span style=color:#f92672>*</span>n_ends);
}
</code></pre></div><p>Go get another coffee. This took ~15 minutes on my machine. In the end, the mathematical solution is the way to go, but it&rsquo;s still fun to explore other solutions.</p>
</div>
<footer class=post-footer>
<ul class=post-tags>
<li><a href=https://mntn.dev/tags/algorithms/>algorithms</a></li>
</ul>
<nav class=paginav>
<a class=prev href=https://mntn.dev/posts/2-requests-cache/>
<span class=title>¬´ Prev Page</span>
<br>
<span>Faster Backtesting with requests-cache</span>
</a>
<a class=next href=https://mntn.dev/posts/4-docker-zfs-deb-1/>
<span class=title>Next Page ¬ª</span>
<br>
<span>Docker & ZFS On Debian</span>
</a>
</nav>
</footer>
</article>
</main>
<footer class=footer>
<span>&copy; 2021 <a href=https://mntn.dev/>mntn.dev</a></span>
<span>
Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://git.io/hugopapermod rel=noopener target=_blank>PaperMod</a>
</span>
</footer>
<a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg>
</a>
<script>let menu=document.getElementById('menu');menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(a=>{a.addEventListener("click",function(b){b.preventDefault();var a=this.getAttribute("href").substr(1);window.matchMedia('(prefers-reduced-motion: reduce)').matches?document.querySelector(`[id='${decodeURIComponent(a)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(a)}']`).scrollIntoView({behavior:"smooth"}),a==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${a}`)})})</script>
<script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script>
<script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove('dark'),localStorage.setItem("pref-theme",'light')):(document.body.classList.add('dark'),localStorage.setItem("pref-theme",'dark'))})</script>
</body>
</html>