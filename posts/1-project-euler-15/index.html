<!doctype html><html lang=en><head><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><title>Project Euler Problem #15 - mntn.dev</title><meta name=generator content="Hugo 0.119.0"><link rel=stylesheet href=/styles.css></head><body class="antialiased bg-amber-100 w-full"><div class="bg-amber-50 flex flex-col items-center min-h-screen mx-auto md:max-w-4xl border-x-2 border-stone-700"><header class="w-full px-8 border-b-2 border-stone-700"><nav class="relative flex items-end justify-between flex-wrap py-4 text-stone-900 text-3xl md:text-4xl"><a href=https://mntn.dev/ class="flex items-center hover:underline decoration-amber-400 font-extrabold">mntn.dev</a><ul id=nav-menu class="flex w-full sm:w-auto mt-2 sm:mt-0 space-x-6 text-xl"><li><a href=https://mntn.dev/projects/ class="hover:underline decoration-amber-400 tracking-tight">Projects</a></li><li><a href=https://mntn.dev/posts/ class="hover:underline decoration-amber-400 tracking-tight">Posts</a></li></ul></nav></header><main class="flex-1 w-full"><article class="justify-self-center mt-4"><div class="border-b-2 border-stone-700 px-8 lg:py-4"><h1 class="text-3xl md:text-4xl text-stone-900 mb-2">Project Euler Problem #15</h1><h3 class="text-stone-900 mb-2 text-sm md:text-lg">November 13, 2020</h3></div><div class="border-b-2 border-stone-700 px-8 mt-4 pb-4"><div class="max-w-none
prose prose-sm prose-stone md:prose-lg
prose-pre:px-8 prose-pre:-mx-8 prose-pre:rounded-none
prose-blockquote:border-l-8
prose-img:mx-auto
prose-figcaption:text-center
hover:prose-a:decoration-amber-400"><h1 id=intro>Intro</h1><p><a href="https://projecteuler.net/problem=15">Problem #15</a> from <a href=https://projecteuler.net/about>Project Euler</a> is a really interesting problem. Not only is there a clean mathematical solution to the question, but there are a <em>bunch</em> of non-optimal (or even downright ugly) but intuitive ways to solve the problem.</p><h1 id=the-easy-way>The Easy Way</h1><p>The easiest, and probably fastest, way to solve this problem is to just use math. Consider the rules of the problem:</p><ol><li>Each path is composed of <em>2N</em> steps that lead from the top left to the bottom right of the domain.</li><li>Each step can only be a rightward or downward move.</li><li>Because of the start and end positions, each path must have an equal number of down and right moves.</li></ol><p>Based on these rules, you can build a valid path by starting with an empty list of <em>2N</em> steps, selecting <em>N</em> steps to place a rightward move, and filling the remaining steps with downward moves. This is a <a href=https://en.wikipedia.org/wiki/Combination>Combination Problem</a>! The number of valid paths you can possibly construct is <em>2N choose N</em>.</p><h1 id=a-fun-way>A Fun Way</h1><figure><img src=treediagram.png><figcaption><h4>a tree</h4></figcaption></figure><p>Maybe you&rsquo;re itching for a reason to think about binary trees. You can look at every step in a path as a node in a binary tree. The starting position is the root node. The root node has two child nodes, one for a downward move and one for a rightward move. Each of those nodes have their own children in the same pattern. This means that two of the &ldquo;grandchild&rdquo; nodes actually describe different paths to the same point. In the above picture, downward moves are to the left and rightward to the right.</p><p>Using this tree, we can describe any path on an infinite grid. To constrain the grid (and know when we&rsquo;ve reached the end point), we need to add some state to each node: an x and y position: (x,y). To create a new downward node in our domain, y must be less than <em>N</em> - the new node&rsquo;s y value will be increased by 1. To create a new rightward node, x must be less than <em>N</em> - we&rsquo;ll increase the node&rsquo;s x. If a new node has state <em>x == N</em> and <em>y == N</em>, we&rsquo;ve hit the end point of the grid!</p><p>If we actually build out this tree to full <em>2N</em> depth, we&rsquo;ll eat up a ton of memory. Conveniently, we don&rsquo;t actually need to hold all of this state since we&rsquo;re only interested in how many nodes in the tree are at the end point. We can just pretend to build the tree with a recursive function. Here&rsquo;s an implementation in RustðŸ¦€:</p><div class=highlight><pre tabindex=0 style=color:#ebdbb2;background-color:#282828;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span><span style=color:#928374;font-style:italic>// The size of our domain in steps
</span></span></span><span style=display:flex><span><span style=color:#928374;font-style:italic>// The grid is NxN steps
</span></span></span><span style=display:flex><span><span style=color:#928374;font-style:italic>// Really, our position grid is N+1xN+1
</span></span></span><span style=display:flex><span><span style=color:#928374;font-style:italic>// [0,0] describes the start and [N,N] describes the end point
</span></span></span><span style=display:flex><span><span style=color:#928374;font-style:italic></span><span style=color:#fe8019>static</span> N:<span style=color:#fabd2f>u32</span> <span style=color:#fe8019>=</span> <span style=color:#d3869b>20</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#fe8019>fn</span> <span style=color:#fabd2f>build_node</span>(x:<span style=color:#fabd2f>u32</span>, y:<span style=color:#fabd2f>u32</span>, n_ends:<span style=color:#fe8019>&amp;</span>mut <span style=color:#fabd2f>u64</span>) {
</span></span><span style=display:flex><span>    <span style=color:#928374;font-style:italic>// If x==y==N, we&#39;re at the end point!
</span></span></span><span style=display:flex><span><span style=color:#928374;font-style:italic></span>    <span style=color:#fe8019>if</span> x <span style=color:#fe8019>==</span> N <span style=color:#fe8019>&amp;&amp;</span> y <span style=color:#fe8019>==</span> N {
</span></span><span style=display:flex><span>        <span style=color:#fe8019>*</span>n_ends <span style=color:#fe8019>+=</span> <span style=color:#d3869b>1</span>;
</span></span><span style=display:flex><span>        <span style=color:#fe8019>return</span>;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    <span style=color:#928374;font-style:italic>// Recurse for each child node if possible
</span></span></span><span style=display:flex><span><span style=color:#928374;font-style:italic></span>    <span style=color:#fe8019>if</span> x <span style=color:#fe8019>&lt;</span> N {
</span></span><span style=display:flex><span>        build_node(x <span style=color:#fe8019>+</span> <span style=color:#d3869b>1</span>, y, n_ends);
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    <span style=color:#fe8019>if</span> y <span style=color:#fe8019>&lt;</span> N {
</span></span><span style=display:flex><span>        build_node(x, y <span style=color:#fe8019>+</span> <span style=color:#d3869b>1</span>, n_ends);
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#fe8019>fn</span> <span style=color:#fabd2f>main</span>() {
</span></span><span style=display:flex><span>    <span style=color:#fe8019>let</span> <span style=color:#fe8019>mut</span> n_ends:<span style=color:#fabd2f>u64</span> <span style=color:#fe8019>=</span> <span style=color:#d3869b>0</span>;
</span></span><span style=display:flex><span>    <span style=color:#928374;font-style:italic>// This describes the root node
</span></span></span><span style=display:flex><span><span style=color:#928374;font-style:italic></span>    build_node(<span style=color:#d3869b>0</span>, <span style=color:#d3869b>0</span>, <span style=color:#fe8019>&amp;</span><span style=color:#fe8019>mut</span> n_ends);
</span></span><span style=display:flex><span>    println!(<span style=color:#b8bb26>&#34;Total unique paths: </span><span style=color:#b8bb26>{}</span><span style=color:#b8bb26>&#34;</span>, n_ends);
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>Go get a coffee or two, because this took ~30min to run on my machine.</p><p><em>Edit: This can be heavily optimized without abandoning the tree structure! More info in <a href=/blog/project-euler-15-addendum>this more recent post</a>.</em></p><h1 id=an-ugly-way>An ugly way</h1><p>Suppose you were told to solve this problem on an FPGA and you have <em>no clue</em> what combination is. Since we know the length of a path is <em>2N</em>, we&rsquo;ll start with a <em>2N</em>-bit wide counter. Let&rsquo;s say down = 1 and right = 0. We can initialize a down-counter with all 1s and let it run all the way down to 0. Since we know a valid path has #rights=#downs=<em>N</em>, we&rsquo;ll look at every counter value and keep track of the number of values which have exactly <em>N</em> ones. That number is the number of possible paths!</p><p>We can even slightly optimize this by recognizing that we only have to evalute all of the paths that start with a downward move and multiply the result by two. This follows from our tree representation above. Rust example below:</p><div class=highlight><pre tabindex=0 style=color:#ebdbb2;background-color:#282828;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span><span style=color:#928374;font-style:italic>// The size of our domain in steps
</span></span></span><span style=display:flex><span><span style=color:#928374;font-style:italic></span><span style=color:#fe8019>static</span> N:<span style=color:#fabd2f>u32</span> <span style=color:#fe8019>=</span> <span style=color:#d3869b>20</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#fe8019>fn</span> <span style=color:#fabd2f>main</span>() {
</span></span><span style=display:flex><span>    <span style=color:#fe8019>let</span> n_ends:<span style=color:#fabd2f>u64</span> <span style=color:#fe8019>=</span> (<span style=color:#d3869b>2</span><span style=color:#fe8019>u64</span>.pow(<span style=color:#d3869b>2</span><span style=color:#fe8019>*</span>N<span style=color:#fe8019>-</span><span style=color:#d3869b>1</span>)<span style=color:#fe8019>..</span><span style=color:#d3869b>2</span><span style=color:#fe8019>u64</span>.pow(<span style=color:#d3869b>2</span><span style=color:#fe8019>*</span>N)).map(<span style=color:#fe8019>|</span>x<span style=color:#fe8019>|</span> (x.count_ones()<span style=color:#fe8019>==</span>N) <span style=color:#fe8019>as</span> <span style=color:#fabd2f>u64</span>).sum();
</span></span><span style=display:flex><span>    println!(<span style=color:#b8bb26>&#34;Total unique paths: </span><span style=color:#b8bb26>{}</span><span style=color:#b8bb26>&#34;</span>, <span style=color:#d3869b>2</span><span style=color:#fe8019>*</span>n_ends);
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>Go get another coffee. This took ~15 minutes on my machine. In the end, the mathematical solution is the way to go, but it&rsquo;s still fun to explore other solutions.</p></div></div></article></main><footer class="relative bottom-0 w-full p-4 text-sm text-center font-mono text-stone-700"><p>Â© 2023 Thomas Gorham | Made with
<a href=https://gohugo.io class="underline hover:text-amber-700">Hugo</a></p></footer></div></body></html>