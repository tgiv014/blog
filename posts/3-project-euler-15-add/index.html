<!doctype html><html lang=en><head><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><title>Project Euler Problem #15 - Addendum - mntn.dev</title><meta name=generator content="Hugo 0.119.0"><link rel=stylesheet href=/styles.css></head><body class="antialiased bg-amber-100 w-full"><div class="bg-amber-50 flex flex-col items-center min-h-screen mx-auto md:max-w-4xl border-x-2 border-stone-700"><header class="w-full px-8 border-b-2 border-stone-700"><nav class="relative flex items-end justify-between flex-wrap py-4 text-stone-900 text-3xl md:text-4xl"><a href=https://mntn.dev/ class="flex items-center hover:underline decoration-amber-400 font-extrabold">mntn.dev</a><ul id=nav-menu class="flex w-full sm:w-auto mt-2 sm:mt-0 space-x-6 text-xl"><li><a href=https://mntn.dev/projects/ class="hover:underline decoration-amber-400 tracking-tight">Projects</a></li><li><a href=https://mntn.dev/posts/ class="hover:underline decoration-amber-400 tracking-tight">Posts</a></li></ul></nav></header><main class="flex-1 w-full"><article class="justify-self-center mt-4"><div class="border-b-2 border-stone-700 px-8 lg:py-4"><h1 class="text-3xl md:text-4xl text-stone-900 mb-2">Project Euler Problem #15 - Addendum</h1><h3 class="text-stone-900 mb-2 text-sm md:text-lg">February 6, 2021</h3></div><div class="border-b-2 border-stone-700 px-8 mt-4 pb-4"><div class="max-w-none
prose prose-sm prose-stone md:prose-lg
prose-pre:px-8 prose-pre:-mx-8 prose-pre:rounded-none
prose-blockquote:border-l-8
prose-img:mx-auto
prose-figcaption:text-center
hover:prose-a:decoration-amber-400"><p><em>This is an addendum to <a href=/blog/project-euler-15>this previous post</a>.</em></p><h1 id=its-learnin-time>It&rsquo;s learnin&rsquo; time</h1><p>While completing advent of code 2020, I learned about <a href=https://en.wikipedia.org/wiki/Memoization>memoization</a>. I realized that this is a perfect problem to apply the technique to. All we need is a hashmap indexed by our tree coordinates that we&rsquo;ll pass in our recursive function. If there&rsquo;s a cached value for the function inputs, we early return the cached value. In our normal return path we save off the calculated value before actually returning it. It&rsquo;s a simple formula for faster processing.</p><p>Without further ado:</p><div class=highlight><pre tabindex=0 style=color:#ebdbb2;background-color:#282828;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span><span style=color:#fe8019>use</span> std::collections::HashMap;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#8ec07c>#[derive(Hash, Eq, PartialEq, Debug)]</span>
</span></span><span style=display:flex><span><span style=color:#fe8019>struct</span> Coordinate {
</span></span><span style=display:flex><span>    x: <span style=color:#fabd2f>u32</span>,
</span></span><span style=display:flex><span>    y: <span style=color:#fabd2f>u32</span>,
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#928374;font-style:italic>// The size of our domain in steps
</span></span></span><span style=display:flex><span><span style=color:#928374;font-style:italic>// The grid is NxN steps
</span></span></span><span style=display:flex><span><span style=color:#928374;font-style:italic>// Really, our position grid is N+1xN+1
</span></span></span><span style=display:flex><span><span style=color:#928374;font-style:italic>// [0,0] describes the start and [N,N] describes the end point
</span></span></span><span style=display:flex><span><span style=color:#928374;font-style:italic></span><span style=color:#fe8019>static</span> N:<span style=color:#fabd2f>u32</span> <span style=color:#fe8019>=</span> <span style=color:#d3869b>20</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#fe8019>fn</span> <span style=color:#fabd2f>build_node</span>(x:<span style=color:#fabd2f>u32</span>, y:<span style=color:#fabd2f>u32</span>, cache:<span style=color:#fe8019>&amp;</span>mut HashMap<span style=color:#fe8019>&lt;</span>Coordinate, <span style=color:#fabd2f>u64</span><span style=color:#fe8019>&gt;</span>) -&gt; <span style=color:#fabd2f>u64</span> {
</span></span><span style=display:flex><span>    <span style=color:#fe8019>let</span> c <span style=color:#fe8019>=</span> Coordinate{x,y};
</span></span><span style=display:flex><span>    <span style=color:#fe8019>let</span> <span style=color:#fe8019>mut</span> sum:<span style=color:#fabd2f>u64</span> <span style=color:#fe8019>=</span> <span style=color:#d3869b>0</span>;
</span></span><span style=display:flex><span>    <span style=color:#fe8019>if</span> cache.contains_key(<span style=color:#fe8019>&amp;</span>c) {
</span></span><span style=display:flex><span>        <span style=color:#fe8019>return</span> cache[<span style=color:#fe8019>&amp;</span>c];
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    <span style=color:#928374;font-style:italic>// If x==y==N, we&#39;re at the end point!
</span></span></span><span style=display:flex><span><span style=color:#928374;font-style:italic></span>    <span style=color:#fe8019>if</span> x <span style=color:#fe8019>==</span> N <span style=color:#fe8019>&amp;&amp;</span> y <span style=color:#fe8019>==</span> N {
</span></span><span style=display:flex><span>        <span style=color:#fe8019>return</span> <span style=color:#d3869b>1</span>;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    <span style=color:#928374;font-style:italic>// Recurse for each child node if possible
</span></span></span><span style=display:flex><span><span style=color:#928374;font-style:italic></span>    <span style=color:#fe8019>if</span> x <span style=color:#fe8019>&lt;</span> N {
</span></span><span style=display:flex><span>        sum <span style=color:#fe8019>+=</span> build_node(x <span style=color:#fe8019>+</span> <span style=color:#d3869b>1</span>, y, cache);
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    <span style=color:#fe8019>if</span> y <span style=color:#fe8019>&lt;</span> N {
</span></span><span style=display:flex><span>        sum <span style=color:#fe8019>+=</span> build_node(x, y <span style=color:#fe8019>+</span> <span style=color:#d3869b>1</span>, cache);
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    cache.insert(c, sum);
</span></span><span style=display:flex><span>    <span style=color:#fe8019>return</span> sum;
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#fe8019>fn</span> <span style=color:#fabd2f>main</span>() {
</span></span><span style=display:flex><span>    <span style=color:#fe8019>let</span> <span style=color:#fe8019>mut</span> cache:HashMap<span style=color:#fe8019>&lt;</span>Coordinate, <span style=color:#fabd2f>u64</span><span style=color:#fe8019>&gt;</span> <span style=color:#fe8019>=</span> HashMap::new();
</span></span><span style=display:flex><span>    <span style=color:#fe8019>let</span> n_ends:<span style=color:#fabd2f>u64</span> <span style=color:#fe8019>=</span> build_node(<span style=color:#d3869b>0</span>, <span style=color:#d3869b>0</span>, <span style=color:#fe8019>&amp;</span><span style=color:#fe8019>mut</span> cache);
</span></span><span style=display:flex><span>    println!(<span style=color:#b8bb26>&#34;Total unique paths: </span><span style=color:#b8bb26>{}</span><span style=color:#b8bb26>&#34;</span>, n_ends);
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>Now it takes ~5ms to evaluate every path in a 20x20 grid! That&rsquo;s a heck of a lot better than 30min.</p></div></div></article></main><footer class="relative bottom-0 w-full p-4 text-sm text-center font-mono text-stone-700"><p>Â© 2023 Thomas Gorham | Made with
<a href=https://gohugo.io class="underline hover:text-amber-700">Hugo</a></p></footer></div></body></html>